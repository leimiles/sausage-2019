#pragma kernel CSMain
#define TWO_PI      6.28318530717958647693

struct VertexAttribute
{
    float3 positionOS;
    float3 normalOS;
    float2 uv;
    float3 color;
};
StructuredBuffer<VertexAttribute> _VertexAttributes;
struct Vertex
{
    float3 positionWS;
    float2 uv;
    float3 diffuseColor;
};
struct Triangle
{
    float3 normalOS;
    Vertex vertices[3];
};
AppendStructuredBuffer<Triangle> _Triangles;
struct IndirectArgs
{
    uint numVerticesPerInstance;
    uint numInstances;
    uint startVertexIndex;
    uint startInstanceIndex;
};
RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;
#define MAX_GRASS_BLADES 15
#define MAX_GRASS_SEGMENTS 5
#define MAX_GRASS_NUM_VERTICES_PER_BLADE ((MAX_GRASS_SEGMENTS) * 2 + 1)

int _NumSourceVertices;
float _Time;
half _GrassHeight;
half _GrassWidth;
float _GrassRandomHeightMin, _GrassRandomHeightMax;
half _WindSpeed;
float _WindStrength;
half _InteractorStrength;
half _BladeRadius;
float _BladeForward;
float _BladeCurve;
float _BottomWidth;
int _MaxBladesPerVertex;
int _MaxSegmentsPerBlade;
float _MinHeight, _MinWidth;
float _MaxHeight, _MaxWidth;
float _MinFadeDist, _MaxFadeDist;
uniform float4 _PositionsMoving[100];
uniform float _InteractorsLength;
uniform float3 _CameraPositionWS;

float3x3 _LocalToWorld;

float rand(float3 co)
{
    return frac(
        sin(dot(co.xyz, float3(12.9898, 78.233, 53.539))) * 43758.5453);
}

// 直接抄 unity
float Unity_RandomRange_float(float2 Seed, float Min, float Max)
{
    float randomno = frac(sin(dot(Seed, float2(12.9898, 78.233))) * 43758.5453);
    return lerp(Min, Max, randomno);
}

// 围绕任意轴旋转
float3x3 AngleAxis3x3(float angle, float3 axis)
{
    float c, s;
    sincos(angle, s, c);

    float t = 1 - c;
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    return float3x3(
        t * x * x + c, t * x * y - s * z, t * x * z + s * y,
        t * x * y + s * z, t * y * y + c, t * y * z - s * x,
        t * x * z - s * y, t * y * z + s * x, t * z * z + c);
}

Vertex GetVertex(float3 positionOS, float width, float height, float offset, float curve, float2 uv, float3x3 rotation, float3 color)
{
    Vertex output = (Vertex)0;
    float3 newPosOS = positionOS + mul(rotation, float3(width, height, curve + offset));
    output.positionWS = float4(newPosOS, 1).xyz;
    output.uv = uv;
    output.diffuseColor = color;
    return output;
}

[numthreads(128, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // 每个 id 获取一个顶点属性
    if ((int)id.x >= _NumSourceVertices)
    {
        return;
    }
    VertexAttribute vertexAttribute = _VertexAttributes[id.x];
    // 太巧了，判断为值不完整，暴力返回
    if (vertexAttribute.positionOS.x == 0 && vertexAttribute.positionOS.y == 0 && vertexAttribute.positionOS.z == 0)
    {
        return;
    }

    // 用于距离剔除
    float3 worldPos = vertexAttribute.positionOS;
    float distanceToCamera = distance(worldPos, _CameraPositionWS);
    float distanceFade = saturate(1 - saturate((distanceToCamera - _MinFadeDist) / (_MaxFadeDist - _MinFadeDist)));

    int numBladesPerVertex = min(MAX_GRASS_BLADES, max(1, _MaxBladesPerVertex));
    int numSegmentsPerBlade = min(MAX_GRASS_SEGMENTS, max(1, _MaxSegmentsPerBlade));
    int numTrianglesPerBlade = (numSegmentsPerBlade - 1) * 2 + 1;

    float3 perpendicularAngle = float3(0, 0, 1);
    float3 faceNormal = vertexAttribute.normalOS;

    // 风力
    float3 wind = float3(sin(_Time.x * _WindSpeed + worldPos.x) + sin(_Time.x * _WindSpeed + worldPos.z * 2) + sin(_Time.x * _WindSpeed * 0.1 + worldPos.x), 0, cos(_Time.x * _WindSpeed + worldPos.x * 2) + cos(_Time.x * _WindSpeed + worldPos.z));
    wind *= _WindStrength;

    float3 color = vertexAttribute.color;

    // 草株的宽度和高度
    _GrassHeight = vertexAttribute.uv.y;
    _GrassWidth = vertexAttribute.uv.x;
    float randomPos = rand(vertexAttribute.positionOS.xyz);

    float randomOffset = Unity_RandomRange_float(vertexAttribute.positionOS.xz, _GrassRandomHeightMin, _GrassRandomHeightMax);
    _GrassHeight = clamp(_GrassHeight + randomOffset, _MinHeight, _MaxHeight);
    _GrassWidth = clamp(_GrassWidth + randomOffset, _MinWidth, _MaxWidth);
    _GrassWidth *= saturate(distanceFade);

    _BladeForward = clamp(_BladeForward + randomOffset, 0, _BladeForward);

    // 通过 loop 生成面片
    for (int j = 0; j < numBladesPerVertex; j++)
    {
        Vertex vertices[MAX_GRASS_NUM_VERTICES_PER_BLADE];
        float3x3 facingRotationMatrix = AngleAxis3x3(randomPos * TWO_PI + j, vertexAttribute.normalOS);
        float bladeRadius = j / (float) numBladesPerVertex;
        float offset = (1 - bladeRadius) * _BladeRadius;
        float3 combinedDisp = 0;
        float3 offsetWorldPos = worldPos + mul(facingRotationMatrix, float3(0, 0, offset));
        for (int p = 0; p < _InteractorsLength; p++)
        {
            float3 playerToVertex = offsetWorldPos - _PositionsMoving[p].xyz;
            float3 directionFromPlayer = normalize(playerToVertex);
            float distanceFromSphere = abs(length(playerToVertex)) + _PositionsMoving[p].w;

            float3 baseXZOffset = float3(directionFromPlayer.x, 0, directionFromPlayer.z) * distanceFromSphere;

            float3 sphereDisp = (baseXZOffset * _InteractorStrength) - float3(0, distanceFromSphere * 1, 0);

            float3 dis = distance(_PositionsMoving[p].xyz, offsetWorldPos);
            float3 radius = 1 - saturate(dis / _PositionsMoving[p].w);

            sphereDisp *= radius ;
            combinedDisp += sphereDisp;

        }

        for (int i = 0; i < numSegmentsPerBlade; i++)
        {

            float t = i / (float) numSegmentsPerBlade;
            float segmentHeight = _GrassHeight * t;
            float segmentWidth = _GrassWidth * (1 - t);

            segmentWidth = i == 0 ? _BottomWidth * segmentWidth : segmentWidth;

            float segmentForward = pow(abs(t), _BladeCurve) * _BladeForward;

            float3 newPos = (i == 0) ? worldPos : worldPos + (combinedDisp * t) + wind * t + saturate(float3(0, 1, 0) * _GrassHeight * t);

            vertices[i * 2] = GetVertex(newPos, segmentWidth, segmentHeight, offset, segmentForward, float2(0, t), facingRotationMatrix, color);

            vertices[i * 2 + 1] = GetVertex(newPos, -segmentWidth, segmentHeight, offset, segmentForward, float2(1, t), facingRotationMatrix, color);
        }

        float3 topPosOS = worldPos + combinedDisp + wind + saturate(float3(0, 1, 0) * _GrassHeight);
        vertices[numSegmentsPerBlade * 2] = GetVertex(topPosOS, 0, _GrassHeight, offset, _BladeForward, float2(0.5, 1), facingRotationMatrix, color);

        for (int k = 0; k < numTrianglesPerBlade; k++)
        {
            Triangle tri = (Triangle)0;
            tri.normalOS = faceNormal;
            tri.vertices[0] = vertices[k];
            tri.vertices[1] = vertices[k + 1];
            tri.vertices[2] = vertices[k + 2];
            _Triangles.Append(tri);
        }
    }
}
